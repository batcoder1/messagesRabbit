'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _fp = require('lodash/fp');

var _createChannel = require('./create-channel');

var _createChannel2 = _interopRequireDefault(_createChannel);

var _getChannelName = require('./get-channel-name');

var _getChannelName2 = _interopRequireDefault(_getChannelName);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultChannelOptions = {
  prefetch: 1
};

const defaultQueueOptions = {
  durable: true,
  maxPriority: 0
};

const defaultRetryQueueOptions = {
  durable: true,
  maxPriority: 10,
  maxLength: 10000
};

const defaultDoneQueueOptions = {
  durable: true,
  maxLength: 10000
};

const assertQueue = (() => {
  var _ref = (0, _asyncToGenerator3.default)(function* (args, plugin) {
    const connection = args.connection,
          queueName = args.queue,
          options = args.options;
    const pluginOptions = plugin.options,
          pluginState = plugin.state;
    const pluginRetryOptions = pluginOptions.retryQueue,
          pluginDoneOptions = pluginOptions.doneQueue;
    const _openChannels = pluginState._openChannels;

    var _ref2 = options || {};

    const userChannelName = _ref2.channelName,
          channelOptions = _ref2.channelOptions,
          queueOptions = _ref2.queueOptions,
          userRetryQueueOptions = _ref2.retryQueueOptions,
          userRetryOptions = _ref2.retryOptions,
          userDoneQueueOptions = _ref2.doneQueueOptions,
          userDoneOptions = _ref2.doneOptions;


    let channel;

    const channelName = userChannelName || (0, _getChannelName2.default)({ method: 'worker', queue: queueName });

    const rQueueOptions = (0, _fp.defaultsDeep)(defaultRetryQueueOptions, userRetryQueueOptions);
    const doneQueueOptions = (0, _fp.defaultsDeep)(defaultDoneQueueOptions, userDoneQueueOptions);

    let retryQueueOptions;
    let retryOptions;
    let doneOptions;

    if (pluginRetryOptions) {
      retryOptions = (0, _fp.defaultsDeep)(pluginRetryOptions, userRetryOptions);
    }

    if (pluginDoneOptions) {
      doneOptions = (0, _fp.defaultsDeep)(pluginDoneOptions, userDoneOptions);
    }

    if (_openChannels[channelName]) {
      channel = _openChannels[channelName].channel;
    } else {
      channel = yield (0, _createChannel2.default)({
        name: channelName,
        options: (0, _fp.defaultsDeep)(defaultChannelOptions, channelOptions),
        persist: true,
        connection
      }, plugin);
    }

    const queuesAsserted = [];

    // Work queue assertion
    const wQueueOptions = (0, _fp.defaultsDeep)(defaultQueueOptions, queueOptions);
    const workQueue = channel.assertQueue(queueName, wQueueOptions);

    queuesAsserted.push(workQueue);

    // Retry queue assertion
    if (retryOptions && retryOptions.suffix) {
      var _retryOptions = retryOptions;
      const suffix = _retryOptions.suffix,
            maxLength = _retryOptions.maxLength;

      const rQueueName = `${queueName}${suffix}`;

      retryQueueOptions = (0, _fp.defaultsDeep)({ maxLength, deadLetterExchange: '', deadLetterRoutingKey: queueName }, rQueueOptions);

      const retryQueue = channel.assertQueue(rQueueName, retryQueueOptions);
      queuesAsserted.push(retryQueue);
    } else {
      queuesAsserted.push(_promise2.default.resolve(null));
    }

    // Done queue assertion
    if (doneOptions && doneOptions.suffix) {
      var _doneOptions = doneOptions;
      const suffix = _doneOptions.suffix,
            maxLength = _doneOptions.maxLength;

      const dQueueName = `${queueName}${suffix}`;

      const dQueueOptions = (0, _fp.defaultsDeep)({ maxLength }, doneQueueOptions);

      const doneQueue = channel.assertQueue(dQueueName, dQueueOptions);
      queuesAsserted.push(doneQueue);
    } else {
      queuesAsserted.push(_promise2.default.resolve(null));
    }

    var _ref3 = yield _promise2.default.all(queuesAsserted),
        _ref4 = (0, _slicedToArray3.default)(_ref3, 3);

    const queue = _ref4[0],
          retryQueue = _ref4[1],
          doneQueue = _ref4[2];


    return {
      channel,
      queue,
      retryQueue,
      retryQueueOptions,
      retryOptions,
      doneQueue,
      doneQueueOptions
    };
  });

  return function assertQueue(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

exports.default = assertQueue;