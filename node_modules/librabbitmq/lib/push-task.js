'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _defaultsDeep = require('lodash/defaultsDeep');

var _defaultsDeep2 = _interopRequireDefault(_defaultsDeep);

var _createChannel = require('./create-channel');

var _createChannel2 = _interopRequireDefault(_createChannel);

var _getChannelName = require('./get-channel-name');

var _getChannelName2 = _interopRequireDefault(_getChannelName);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultQueueOptions = {
  durable: true,
  maxPriority: 0
};

const pushTask = (() => {
  var _ref = (0, _asyncToGenerator3.default)(function* (args, plugin) {
    const connection = args.connection,
          queueName = args.queue,
          payload = args.payload,
          type = args.type,
          correlationId = args.correlationId,
          options = args.options;
    const pluginOptions = plugin.options,
          pluginState = plugin.state;
    const preserveChannels = pluginOptions.preserveChannels,
          retryOptions = pluginOptions.retry;
    const _openChannels = pluginState._openChannels;

    var _ref2 = options || {};

    const userChannelName = _ref2.channelName,
          channelOptions = _ref2.channelOptions,
          queueOptions = _ref2.queueOptions,
          taskOptions = _ref2.taskOptions;


    let channel;

    try {
      const channelName = userChannelName || (0, _getChannelName2.default)({ method: 'pushTask', queue: queueName });

      const defaultTaskOptions = {
        persistent: true,
        priority: 0,
        contentType: 'application/json',
        contentEncoding: 'utf-8',
        headers: {
          'x-retry-count': retryOptions === false ? -1 : 0
        }
      };

      const mergedTaskOptions = (0, _defaultsDeep2.default)({}, taskOptions, defaultTaskOptions);

      if (type) {
        mergedTaskOptions.type = type;
      }

      if (correlationId) {
        mergedTaskOptions.correlationId = String(correlationId);
      }

      if (_openChannels[channelName]) {
        channel = _openChannels[channelName].channel;
      } else {
        channel = yield (0, _createChannel2.default)({
          name: channelName,
          options: channelOptions,
          connection
        }, plugin);
      }

      const queue = yield channel.assertQueue(queueName, (0, _defaultsDeep2.default)({}, queueOptions, defaultQueueOptions));

      const queued = yield channel.sendToQueue(queue.queue, Buffer.from((0, _stringify2.default)(payload), mergedTaskOptions.contentEncoding), mergedTaskOptions);

      if (!preserveChannels) {
        channel.close();
        channel = null;
        return {
          queue,
          queued
        };
      }

      return {
        channel,
        queue,
        queued
      };
    } catch (error) {
      throw error;
    } finally {
      if (!preserveChannels && channel) {
        channel.close();
      }
    }
  });

  return function pushTask(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

exports.default = pushTask;