'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defaultsDeep = require('lodash/defaultsDeep');

var _defaultsDeep2 = _interopRequireDefault(_defaultsDeep);

var _isUndefined = require('lodash/isUndefined');

var _isUndefined2 = _interopRequireDefault(_isUndefined);

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getPriority = function getPriority({ maxPriority, maxCount, retryCount }) {
  return maxPriority - Math.floor(retryCount * maxPriority / maxCount);
};

const getFailReason = function getFailReason({ retryCount, maxCount, error }) {
  const fail = {};

  if (error) {
    fail.error = error;
  }

  if (!(0, _isUndefined2.default)(retryCount) && retryCount >= maxCount) {
    fail.reason = `Max retries exceeded ${retryCount} >= ${maxCount}`;
  } else {
    fail.reason = 'General failure';
  }

  return fail;
};

const sendToDoneQueue = function sendToDoneQueue({ channel, doneQueue, maxCount }) {
  return ({ retryCount, error, result, properties, content }) => {
    const done = {};

    if (error || retryCount) {
      done.fail = getFailReason({ maxCount, retryCount, error });
    }

    if (result) {
      done.result = result;
    }

    const options = {
      headers: {
        'x-done': done,
        'x-original-properties': properties
      }
    };
    channel.sendToQueue(doneQueue.queue, content, options);
  };
};

const sendToRetryQueue = function sendToRetryQueue({
  channel,
  queue,
  retryOptions,
  retryQueueOptions
}) {
  var _ref = retryQueueOptions || {};

  const maxPriority = _ref.maxPriority;

  var _ref2 = retryOptions || {};

  const maxCount = _ref2.maxCount,
        factor = _ref2.factor,
        minTimeout = _ref2.minTimeout,
        maxTimeout = _ref2.maxTimeout,
        suffix = _ref2.suffix;


  return ({ retryCount, properties, content }) => {
    let priority = 0;
    let expiration = properties.expiration,
        headers = properties.headers;

    const deathHeader = headers['x-death'];

    if (suffix) {
      if (deathHeader && deathHeader.length) {
        expiration = Number(deathHeader[0]['original-expiration'] || 0);
        expiration *= deathHeader[0].count + 1;
      } else {
        expiration = Number(expiration || 0);
      }

      expiration = Math.max(expiration, minTimeout);

      if (retryCount > 0) {
        expiration = Math.min(expiration * factor, maxTimeout);
      }

      if (maxPriority) {
        priority = getPriority({ maxPriority, maxCount, retryCount });
      }
    }

    const options = (0, _defaultsDeep2.default)({}, {
      priority,
      expiration,
      headers: {
        'x-retry-count': retryCount + 1
      }
    }, properties);

    channel.sendToQueue(queue.queue, content, options);
  };
};

const consumerFactory = function consumerFactory({
  channel,
  queue,
  worker,
  retryQueue,
  retryQueueOptions,
  retryOptions,
  doneQueue
}) {
  var _ref3 = retryOptions || {};

  const maxCount = _ref3.maxCount;


  let retry;
  if (retryOptions) {
    retry = sendToRetryQueue({
      channel,
      queue: retryQueue || queue,
      retryOptions,
      retryQueueOptions
    });
  }

  let finished;
  if (doneQueue) {
    finished = sendToDoneQueue({
      channel,
      doneQueue,
      maxCount
    });
  }

  return message => {
    const content = message.content,
          properties = message.properties;
    const contentType = properties.contentType,
          contentEncoding = properties.contentEncoding;


    let payload = content.toString(contentEncoding);

    if (contentType === 'application/json') {
      payload = JSON.parse(payload);
    }

    const consumerObj = {
      raw: message,
      properties,
      payload,
      channel,
      queue
    };

    const onResult = result => {
      if (typeof result === 'string') {
        result = { code: result };
      }

      if (result && result.code) {
        if (result.code === _constants.ACK) {
          channel.ack(message);
        } else if (result.code === _constants.NACK) {
          channel.nack(message);
        } else if (result.code === _constants.REJECT) {
          channel.ack(message);
        } else if (result.code === _constants.RETRY) {
          throw new Error('retry requested');
        }
      }

      if (finished) {
        finished({ properties, content, result });
      }
    };

    const onError = error => {
      if (!retry && !finished) {
        // Conventional behavior
        return channel.nack(message);
      }

      const headers = properties.headers;

      const retryCountHeader = headers['x-retry-count'];

      // Will require more work
      channel.ack(message);

      // Some form of retry requested
      let shouldRetry = false;
      let retryCount;

      if (!(0, _isUndefined2.default)(retryCountHeader)) {
        retryCount = Number(retryCountHeader);
        shouldRetry = retryCount > -1 && retryCount < maxCount;
      }

      if (shouldRetry && retry) {
        retry({ properties, content, retryCount });
        return;
      }

      // No retries, but doneQueue is configured
      if (finished) {
        finished({ properties, content, retryCount, error });
      }
    };

    worker(consumerObj).then(onResult).catch(onError);
  };
};

exports.default = consumerFactory;